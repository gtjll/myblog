(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{293:function(t,e,n){"use strict";n.r(e);var a=n(5),o=Object(a.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"学习react-hooks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#学习react-hooks","aria-hidden":"true"}},[t._v("#")]),t._v(" 学习react hooks")]),t._v(" "),n("h3",{attrs:{id:"学习react-hooks遇到的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#学习react-hooks遇到的问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 学习react hooks遇到的问题")]),t._v(" "),n("ol",[n("li",[t._v("typeerror object(...) is not a function react hooks\nreact版本问题，要16.7.0-alpha.2 或者 next 版本(which we've fixed to point to it) should work.")]),t._v(" "),n("li",[t._v("TypeError: dispatcher.useState is not a function\nreact-dom的版本要跟react版本一致")]),t._v(" "),n("li",[t._v("Hooks can only be called inside the body of a function component.\n用mobx的observer包裹function based 组件会报错\nmobx作者出了一个mobx-react-lite包来fix这个问题"),n("a",{attrs:{href:"https://github.com/mobxjs/mobx-react-lite",target:"_blank",rel:"noopener noreferrer"}},[t._v("mobx-react-lite"),n("OutboundLink")],1),t._v("\n使用mobx-react-lite 包中的observer,const myFunComp=observer(()=>{})\nmobx-react-lite包中"),n("Observer",[t._v("{()=>{}}")]),t._v(" 没有起作用")],1)]),t._v(" "),n("h2",{attrs:{id:"react-hooks-api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks-api","aria-hidden":"true"}},[t._v("#")]),t._v(" react hooks API")]),t._v(" "),n("h3",{attrs:{id:"usestate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usestate","aria-hidden":"true"}},[t._v("#")]),t._v(" useState")]),t._v(" "),n("p",[n("strong",[t._v("const [state, setState] = useState(initialState);")]),t._v("\n举例：\nconst [visible, setVisible] = useState(false);\ninitialState是visible的初始值，visible相当于设了一个state={visible:false},setVisible类似于于setState，名字可以随意取，改变visible的值的话直接把最新的值当作参数传进去，例如setVisible(true)这样，\n在后续重新渲染期间，useState 返回的第一个值将始终是应用更新后的最新 state(状态)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Counter({initialCount}) {\n  const [count, setCount] = useState(initialCount);\n  return (\n    <>\n      Count: {count}\n      <button onClick={() => setCount(initialCount)}>Reset</button>\n      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>\n      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>\n    </>\n  );\n}\n")])])]),n("h3",{attrs:{id:"usereducer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usereducer","aria-hidden":"true"}},[t._v("#")]),t._v(" useReducer")]),t._v(" "),n("p",[n("strong",[t._v("const [state, dispatch] = useReducer(reducer, initialArg, init);")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const initialState = {count: 0};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return {count: state.count + 1};\n    case 'decrement':\n      return {count: state.count - 1};\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter({initialCount}) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\n    </>\n  );\n}\n")])])]),n("h3",{attrs:{id:"useeffect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useeffect","aria-hidden":"true"}},[t._v("#")]),t._v(" useEffect")]),t._v(" "),n("p",[n("strong",[t._v("useEffect(didUpdate);")])]),t._v(" "),n("p",[t._v("useEffect为了达到一些副作用，类似订阅，计时器，日志记录等\nuseEffect 的参数是一个函数，组件每次渲染之后，都会调用这个函数参数，类似componentDidMount 和 componentDidUpdate 作用。\n先看一段用生命周期写的代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  componentDidMount() {\n    chart = echarts.init(chartDom.current);\n    window.addEventListener('resize', chart.resize);\n    setOption();\n  }\n\n  componentDidUpdate() {\n    setOption();\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', chart.resize);\n  }\n")])])]),n("p",[t._v("setOption在componentDidMount和componentDidUpdate 都要被调用，就可以在useEffect 中写，写成"),n("br"),t._v("\nuseEffect(() => {\nsetOption();\n});")]),t._v(" "),n("p",[t._v("但是添加监听器和取消监听器只需要在componentDidMount和componentWillUnmount操作，针对只需要componentDidMount调用一次的情况，useEffect接受第二个参数，设第二个参数为空数组，就不会引发componentDidUpdate的调用。只有数组中的值发生改变才会引发componentDidUpdate的调用。\n如果要模拟componentWillUnmount调用的操作呢，只要在函数中返回一个函数，返回的函数就会在组件卸载之前调用")]),t._v(" "),n("p",[t._v("再看useEffect写的代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\n  useEffect(() => {\n    chart = echarts.init(chartDom.current);\n    window.addEventListener('resize', chart.resize);\n\n    return () => {\n      window.removeEventListener('resize', chart.resize);\n    };\n  }, []);\n\n  useEffect(() => {\n    setOption();\n  });\n")])])]),n("p",[t._v("这样就可以把相同的功能放在一个useEffect中，而不是分散在生命周期中。这也是官网上说写hooks的动机之一。"),n("a",{attrs:{href:"https://reactjs.org/docs/hooks-intro.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("跳转到react官网"),n("OutboundLink")],1)]),t._v(" "),n("h3",{attrs:{id:"useref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useref","aria-hidden":"true"}},[t._v("#")]),t._v(" useRef")]),t._v(" "),n("p",[n("strong",[t._v("const refContainer = useRef(initialValue);")]),t._v("\nuseRef 返回一个可变的 ref 对象，initialValue会初始化refContainer .current 属性。返回的对象将存留在整个组件的生命周期中。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function TextInputWithFocusButton() {\n  const inputEl = useRef(null);\n  const onButtonClick = () => {\n    // `current` points to the mounted text input element\n    inputEl.current.focus();\n  };\n  return (\n    <>\n      <input ref={inputEl} type="text" />\n      <button onClick={onButtonClick}>Focus the input</button>\n    </>\n  );\n}\n')])])]),n("p",[t._v("摘抄")]),t._v(" "),n("p",[t._v("自定义hook\n这是hook唯一可以写在component函数之外的地方")]),t._v(" "),n("p",[t._v("写个简单的例子")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function useNumberInput(init) {\n  const [value, setValue] = useState(init);\n  const onInput = e => {\n    const val = +e.target.value;\n    if (Number.isNaN(val)) return;\n    setValue(val);\n  }\n  return { value, onInput };\n}\n\nfunction App() {\n  const foo = useNumberInput(123);\n  return (\n    <>\n      <div><input {...foo} /></div>\n      <p>value={foo.value}</p>\n      <p>typeof value={typeof foo.value}</p>\n    </>\n  );\n}\n")])])]),n("p",[t._v("参考文献：\n"),n("a",{attrs:{href:"https://segmentfault.com/a/1190000017483690#articleHeader12",target:"_blank",rel:"noopener noreferrer"}},[t._v("全面了解 React 新功能: Suspense 和 Hooks"),n("OutboundLink")],1)])])},[],!1,null,null,null);e.default=o.exports}}]);